---
import { Component, isComponent, NodeType } from "../lib/internal";
import { getWarningMessage } from "../lib/warnings";
import type {
  MissingComponentHandler,
  PortableTextComponents,
  Props as ComponentProps,
} from "../lib/types";
import { setContext } from "../lib/context";
import Empty from "./Empty.astro";

export interface Props {
  nodeType: NodeType;
  type: string;
  components: PortableTextComponents;
  componentProps: ComponentProps;
  onMissingComponent: MissingComponentHandler;
}

const {
  nodeType,
  type,
  components,
  componentProps: props,
  onMissingComponent,
} = Astro.props;

const unknownType = ((str) => {
  return `unknown${str}` as keyof PortableTextComponents;
})(nodeType[0].toUpperCase() + nodeType.slice(1));

const provideComponent = (
  type: keyof PortableTextComponents,
  key?: string
): Component => {
  const componentOrRecord = components[type];

  if (isComponent(componentOrRecord)) {
    return componentOrRecord;
  }

  if (key && key in componentOrRecord) {
    return componentOrRecord[key as keyof typeof componentOrRecord];
  }

  return components[unknownType] as Component;
};

const Cmp = provideComponent(nodeType, type);
const NextCmp = provideComponent(unknownType);

Object.defineProperty(props.node, "$$key", {
  value: Symbol("astro-portabletext"),
  writable: false,
});

const next = (
  (cmps) => () =>
    cmps.shift() ?? Empty
)(
  Cmp === NextCmp
    ? [
        /* leave empty to avoid duplicating output */
      ]
    : [NextCmp]
);

setContext(props.node, {
  next: next,
  getWarningMessage: () => getWarningMessage(nodeType, type),
  onMissingComponent: (message?: string) =>
    onMissingComponent(message ?? getWarningMessage(nodeType, type), {
      nodeType,
      type,
    }),
});
---

<Cmp {...props}>
  <slot />
</Cmp>
