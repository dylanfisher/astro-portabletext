---
import { Component, isComponent, NodeType } from "../lib/internal";
import { getWarningMessage } from "../lib/warnings";
import type {
  MissingComponentHandler,
  PortableTextComponents,
} from "../lib/types";
import { setContext } from "../lib/context";

export interface Props {
  nodeType: NodeType;
  type: string;
  components: PortableTextComponents;
  componentProps: any;
  onMissingComponent: MissingComponentHandler;
}

const {
  nodeType,
  type,
  components,
  componentProps: props,
  onMissingComponent,
} = Astro.props;

const unknownType = ((str) => {
  return `unknown${str}` as keyof PortableTextComponents;
})(nodeType[0].toUpperCase() + nodeType.slice(1));

const provideComponent = (
  type: keyof PortableTextComponents,
  key?: string
): Component => {
  const componentOrRecord = components[type];

  if (isComponent(componentOrRecord)) {
    return componentOrRecord;
  }

  if (key && key in componentOrRecord) {
    return componentOrRecord[key as keyof typeof componentOrRecord];
  }

  return components[unknownType] as Component;
};

const Primary = provideComponent(nodeType, type);
const Secondary = provideComponent(unknownType);

Object.defineProperties(props, {
  $$key: { value: Symbol("astro-portabletext"), writable: false },
  node: { value: props.node, writable: false },
  index: { value: props.index, writable: false },
  isInline: { value: props.isInline, writable: false },
});

setContext(props.node, {
  next: () => Secondary,
  getWarningMessage: () => getWarningMessage(nodeType, type),
  onMissingComponent: (message?: string) =>
    onMissingComponent(message ?? getWarningMessage(nodeType, type), {
      nodeType,
      type,
    }),
});
---

<Primary {...props}>
  <slot />
</Primary>
