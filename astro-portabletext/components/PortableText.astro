---
import {
  isPortableTextBlock,
  isPortableTextListItemBlock,
  isPortableTextToolkitList,
  isPortableTextToolkitSpan,
  isPortableTextToolkitTextNode,
  nestLists,
  buildMarksTree,
  LIST_NEST_MODE_HTML,
} from "@portabletext/toolkit";

import type { PortableTextBlock } from "@portabletext/types";

import type {
  MissingComponentHandler,
  PortableTextComponents,
  PortableTextProps,
  Props as ComponentProps,
  TypedObject,
} from "../lib/types";

import type { NodeType } from "../lib/internal";

import { isComponent, mergeComponents } from "../lib/internal";

import { printWarning } from "../lib/warnings";

import NodeRenderer from "./NodeRenderer.astro";
import Block from "./Block.astro";
import HardBreak from "./HardBreak.astro";
import List from "./List.astro";
import ListItem from "./ListItem.astro";
import Raw from "./Raw.astro";
import Mark from "./Mark.astro";
import UnknownBlock from "./UnknownBlock.astro";
import UnknownList from "./UnknownList.astro";
import UnknownListItem from "./UnknownListItem.astro";
import UnknownMark from "./UnknownMark.astro";
import UnknownType from "./UnknownType.astro";

export interface Props extends PortableTextProps {
  class?: astroHTML.JSX.HTMLAttributes["class"];
}

const {
  value,
  components: componentOverrides = {},
  listNestingMode = LIST_NEST_MODE_HTML,
  onMissingComponent = true,
  class: astroClass,
} = Astro.props;

const components = mergeComponents(
  {
    type: {},
    unknownType: UnknownType,
    block: {
      h1: Block,
      h2: Block,
      h3: Block,
      h4: Block,
      h5: Block,
      h6: Block,
      blockquote: Block,
      normal: Block,
    },
    unknownBlock: UnknownBlock,
    list: {
      bullet: List,
      number: List,
    },
    unknownList: UnknownList,
    listItem: {
      bullet: ListItem,
      number: ListItem,
    },
    unknownListItem: UnknownListItem,
    mark: {
      code: Mark,
      em: Mark,
      link: Mark,
      "strike-through": Mark,
      strong: Mark,
      underline: Mark,
    },
    unknownMark: UnknownMark,
    hardBreak: HardBreak,
  },
  componentOverrides
) as PortableTextComponents;

const noop = () => {};

const missingComponentHandler = ((
  handler: unknown
): MissingComponentHandler => {
  if (typeof handler === "function") {
    return handler as MissingComponentHandler;
  }
  return !handler ? noop : printWarning;
})(onMissingComponent);

const blocks = Array.isArray(value) ? value : [value];

const serializeNode =
  (isInline: boolean) =>
  (node: TypedObject, index: number = 0) =>
    asComponentProps(node, index, isInline);

const serializeChildren = (
  node: TypedObject & { children: TypedObject[] },
  isInline: boolean
) => node.children.map(serializeNode(isInline));

const serializeMarksTree = (node: PortableTextBlock) =>
  buildMarksTree(node).map(serializeNode(true));

const asComponentProps = (
  node: TypedObject,
  index: number,
  isInline: boolean
): ComponentProps => ({
  node,
  index,
  isInline,
  class: astroClass,
});

const Br = isComponent(components["hardBreak"])
  ? components["hardBreak"]
  : HardBreak;
---

{
  nestLists(blocks, listNestingMode)
    .map((node) => asComponentProps(node, 0, false))
    .map(function renderNode(it) {
      const { node, ...props } = it;

      const nodeRendererProps = (nodeType: NodeType, type: string) => {
        if ("block" === nodeType) {
          it.node.style = type; // Ensure style is set
        }

        return {
          nodeType,
          type,
          components,
          componentProps: it,
          onMissingComponent: missingComponentHandler,
        };
      };

      return isPortableTextToolkitList(node) ? (
        <NodeRenderer {...nodeRendererProps("list", node.listItem)}>
          <Raw value={serializeChildren(node, false).map(renderNode)} />
        </NodeRenderer>
      ) : isPortableTextListItemBlock(node) ? (
        <NodeRenderer {...nodeRendererProps("listItem", node.listItem)}>
          <Raw
            value={serializeMarksTree(node)
              .map(renderNode)
              .map((children) => {
                if (node.style !== "normal") {
                  const { listItem, ...blockNode } = node;
                  children = renderNode(serializeNode(false)(blockNode, 0));
                }
                return children;
              })}
          />
        </NodeRenderer>
      ) : isPortableTextToolkitSpan(node) ? (
        <NodeRenderer {...nodeRendererProps("mark", node.markType)}>
          <Raw value={serializeChildren(node, true).map(renderNode)} />
        </NodeRenderer>
      ) : isPortableTextBlock(node) ? (
        <NodeRenderer {...nodeRendererProps("block", node.style ?? "normal")}>
          <Raw value={serializeMarksTree(node).map(renderNode)} />
        </NodeRenderer>
      ) : isPortableTextToolkitTextNode(node) ? (
        "\n" === node.text && components["hardBreak"] ? (
          <Br node={node} {...props} />
        ) : (
          <Fragment set:text={node.text} />
        )
      ) : (
        <NodeRenderer {...nodeRendererProps("type", node._type)} />
      );
    })
}
