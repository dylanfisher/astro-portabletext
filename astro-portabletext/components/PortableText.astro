---
import {
  isPortableTextBlock,
  isPortableTextListItemBlock,
  isPortableTextToolkitList,
  isPortableTextToolkitSpan,
  isPortableTextToolkitTextNode,
  nestLists,
  buildMarksTree,
  LIST_NEST_MODE_HTML,
} from "@portabletext/toolkit";

import type { PortableTextBlock } from "@portabletext/types";

import type {
  MissingComponentHandler,
  PortableTextComponents,
  PortableTextProps,
  Props as ComponentProps,
  TypedObject,
} from "../lib/types";

import type { Component } from "../lib/internal";
import { isComponent, mergeComponents } from "../lib/internal";

import { getWarningMessage, printWarning } from "../lib/warnings";

import type { Context } from "../lib/context";
import { key as contextRef } from "../lib/context";

import Block from "./Block.astro";
import HardBreak from "./HardBreak.astro";
import List from "./List.astro";
import ListItem from "./ListItem.astro";
import Mark from "./Mark.astro";
import UnknownBlock from "./UnknownBlock.astro";
import UnknownList from "./UnknownList.astro";
import UnknownListItem from "./UnknownListItem.astro";
import UnknownMark from "./UnknownMark.astro";
import UnknownType from "./UnknownType.astro";

export interface Props extends PortableTextProps {
  class?: astroHTML.JSX.HTMLAttributes["class"];
}

const {
  value,
  components: componentOverrides = {},
  listNestingMode = LIST_NEST_MODE_HTML,
  onMissingComponent = true,
  class: astroClass,
} = Astro.props;

const components = mergeComponents(
  {
    type: {},
    unknownType: UnknownType,
    block: {
      h1: Block,
      h2: Block,
      h3: Block,
      h4: Block,
      h5: Block,
      h6: Block,
      blockquote: Block,
      normal: Block,
    },
    unknownBlock: UnknownBlock,
    list: {
      bullet: List,
      number: List,
    },
    unknownList: UnknownList,
    listItem: {
      bullet: ListItem,
      number: ListItem,
    },
    unknownListItem: UnknownListItem,
    mark: {
      code: Mark,
      em: Mark,
      link: Mark,
      "strike-through": Mark,
      strong: Mark,
      underline: Mark,
    },
    unknownMark: UnknownMark,
    hardBreak: HardBreak,
  },
  componentOverrides
) as PortableTextComponents;

const noop = () => {};

const missingComponentHandler = ((
  handler: unknown
): MissingComponentHandler => {
  if (typeof handler === "function") {
    return handler as MissingComponentHandler;
  }
  return !handler ? noop : printWarning;
})(onMissingComponent);

const blocks = Array.isArray(value) ? value : [value];

const serializeNode =
  (isInline: boolean) =>
  (node: TypedObject, index: number = 0) =>
    asComponentProps(node, index, isInline);

const serializeChildren = (
  node: TypedObject & { children: TypedObject[] },
  isInline: boolean
) => node.children.map(serializeNode(isInline));

const serializeMarksTree = (node: PortableTextBlock) =>
  buildMarksTree(node).map(serializeNode(true));

const asComponentProps = (
  node: TypedObject,
  index: number,
  isInline: boolean
): ComponentProps => ({
  node,
  index,
  isInline,
  class: astroClass,
});

const provideComponent = (nodeType: keyof typeof components, type: string) => {
  const component = components[nodeType];

  return isComponent(component)
    ? component
    : components[nodeType][type as keyof typeof component];
};

const prepareForRender = (props: ComponentProps) => {
  const { node } = props;

  const $: (
    nodeSpec: { nodeType: string; type: string | null },
    component: Component | string,
    children?: ComponentProps[]
  ) => [typeof component, ComponentProps[]] = (
    nodeSpec,
    component,
    children
  ) => {
    Object.defineProperty(props.node, contextRef, {
      value: nodeSpec,
    });

    return [component, children ?? []];
  };

  return isPortableTextToolkitList(node)
    ? ((spec) =>
        $(
          spec,
          provideComponent(spec.nodeType, spec.type) ?? components.unknownList,
          serializeChildren(node, false)
        ))({ nodeType: "list" as keyof typeof components, type: node.listItem })
    : isPortableTextListItemBlock(node)
    ? ((spec) =>
        $(
          spec,
          provideComponent(spec.nodeType, spec.type) ??
            components.unknownListItem,
          serializeMarksTree(node).map((children) => {
            if (node.style !== "normal") {
              const { listItem, ...blockNode } = node;
              children = serializeNode(false)(blockNode, 0);
            }
            return children;
          })
        ))({
        nodeType: "listItem" as keyof typeof components,
        type: node.listItem,
      })
    : isPortableTextToolkitSpan(node)
    ? ((spec) =>
        $(
          spec,
          provideComponent(spec.nodeType, spec.type) ?? components.unknownMark,
          serializeChildren(node, true)
        ))({ nodeType: "mark" as keyof typeof components, type: node.markType })
    : isPortableTextBlock(node)
    ? ((spec) => {
        props.node = { style: spec.type, ...node };

        return $(
          spec,
          provideComponent(spec.nodeType, spec.type) ?? components.unknownBlock,
          serializeMarksTree(node)
        );
      })({
        nodeType: "block" as keyof typeof components,
        type: node.style ?? "normal",
      })
    : isPortableTextToolkitTextNode(node)
    ? ((spec) =>
        $(
          spec,
          "\n" === node.text && isComponent(components.hardBreak)
            ? components.hardBreak
            : node.text
        ))({ nodeType: "text", type: null })
    : ((spec) =>
        $(
          spec,
          provideComponent(spec.nodeType, spec.type) ?? components.unknownType
        ))({ nodeType: "type" as keyof typeof components, type: node._type });
};

(globalThis as any)[contextRef] = (node: TypedObject): Context => {
  const notifyMissingComponentHandler = (message?: string) => {
    provideMissingComponentHandler(
      message ?? provideWarningMessage(node),
      (node as any)[contextRef]
    );
  };

  return {
    getDefaultComponent: provideDefaultComponent.bind(null, node),
    getUnknownComponent: provideUnknownComponent.bind(null, node),
    getWarningMessage: provideWarningMessage.bind(null, node),
    notifyMissingComponentHandler: notifyMissingComponentHandler,
    /** @deprecated Use `getDefaultComponent` */
    next: () => provideDefaultComponent(node),
    /** @deprecated Use `notifyMissingComponentHandler` */
    onMissingComponent: notifyMissingComponentHandler,
  };
};

// Set `provideDefaultComponent` on context
const provideDefaultComponent = (node: TypedObject): any => {
  const { nodeType } = (node as any)[contextRef];

  return nodeType === "list" || isPortableTextToolkitList(node)
    ? List
    : nodeType === "listItem" || isPortableTextListItemBlock(node)
    ? ListItem
    : nodeType === "mark" || isPortableTextToolkitSpan(node)
    ? Mark
    : nodeType === "block" || isPortableTextBlock(node)
    ? Block
    : // Should we try for `type`?
      (() => {
        throw new Error(
          `[PortableText provideComponent()] Unable to provide component with node type ${node._type}`
        );
      })();
};

// Set `provideUnknownComponent` on context
const provideUnknownComponent = (node: TypedObject) => {
  const { nodeType } = (node as any)[contextRef];

  return (
    nodeType === "list" || isPortableTextToolkitList(node)
      ? components.unknownList
      : nodeType === "listItem" || isPortableTextListItemBlock(node)
      ? components.unknownListItem
      : nodeType === "mark" || isPortableTextToolkitSpan(node)
      ? components.unknownMark
      : nodeType === "block" || isPortableTextBlock(node)
      ? components.unknownBlock
      : nodeType === "type" || !isPortableTextToolkitTextNode(node)
      ? components.unknownType
      : (() => {
          throw new Error(
            `[PortableText provideUnknownComponent()] Unable to provide component with node type ${node._type}`
          );
        })()
  ) as Component;
};

// Set `provideWarningMessage` on context
const provideWarningMessage = (node: TypedObject) => {
  const { nodeType, type } = (node as any)[contextRef];

  return getWarningMessage(nodeType, type);
};

// Set `missingComponentHandler` on context
const provideMissingComponentHandler = missingComponentHandler;

// Using a generator to avoid creating a new array
function* renderBlocks() {
  for (const it of nestLists(blocks, listNestingMode)) {
    yield asComponentProps(it, 0, false);
  }
}
---

{
  [...renderBlocks()].map(function render(props) {
    const [Cmp, children] = prepareForRender(props);

    return !isComponent(Cmp) ? (
      <Fragment set:text={Cmp} />
    ) : (
      <Cmp {...props}>{children.map(render)}</Cmp>
    );
  })
}
