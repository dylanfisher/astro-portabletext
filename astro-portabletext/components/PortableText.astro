---
import {
  isPortableTextBlock,
  isPortableTextListItemBlock,
  isPortableTextToolkitList,
  isPortableTextToolkitSpan,
  isPortableTextToolkitTextNode,
  nestLists,
  buildMarksTree,
  LIST_NEST_MODE_HTML,
} from "@portabletext/toolkit";

import type { PortableTextBlock } from "@portabletext/types";

import type {
  MissingComponentHandler,
  PortableTextComponents,
  PortableTextProps,
  Props as ComponentProps,
  TypedObject,
} from "../lib/types";

import type { Component } from "../lib/internal";
import { isComponent, mergeComponents } from "../lib/internal";

import { getWarningMessage, printWarning } from "../lib/warnings";
import context, { key as nodeTypeRef } from "../lib/context";

import Block from "./Block.astro";
import HardBreak from "./HardBreak.astro";
import List from "./List.astro";
import ListItem from "./ListItem.astro";
import Mark from "./Mark.astro";
import UnknownBlock from "./UnknownBlock.astro";
import UnknownList from "./UnknownList.astro";
import UnknownListItem from "./UnknownListItem.astro";
import UnknownMark from "./UnknownMark.astro";
import UnknownType from "./UnknownType.astro";

export interface Props extends PortableTextProps {
  class?: astroHTML.JSX.HTMLAttributes["class"];
}

const {
  value,
  components: componentOverrides = {},
  listNestingMode = LIST_NEST_MODE_HTML,
  onMissingComponent = true,
  class: astroClass,
} = Astro.props;

const components = mergeComponents(
  {
    type: {},
    unknownType: UnknownType,
    block: {
      h1: Block,
      h2: Block,
      h3: Block,
      h4: Block,
      h5: Block,
      h6: Block,
      blockquote: Block,
      normal: Block,
    },
    unknownBlock: UnknownBlock,
    list: {
      bullet: List,
      number: List,
    },
    unknownList: UnknownList,
    listItem: {
      bullet: ListItem,
      number: ListItem,
    },
    unknownListItem: UnknownListItem,
    mark: {
      code: Mark,
      em: Mark,
      link: Mark,
      "strike-through": Mark,
      strong: Mark,
      underline: Mark,
    },
    unknownMark: UnknownMark,
    hardBreak: HardBreak,
  },
  componentOverrides
) as PortableTextComponents;

const noop = () => {};

const missingComponentHandler = ((
  handler: unknown
): MissingComponentHandler => {
  if (typeof handler === "function") {
    return handler as MissingComponentHandler;
  }
  return !handler ? noop : printWarning;
})(onMissingComponent);

const blocks = Array.isArray(value) ? value : [value];

const serializeNode =
  (isInline: boolean) =>
  (node: TypedObject, index: number = 0) =>
    asComponentProps(node, index, isInline);

const serializeChildren = (
  node: TypedObject & { children: TypedObject[] },
  isInline: boolean
) => node.children.map(serializeNode(isInline));

const serializeMarksTree = (node: PortableTextBlock) =>
  buildMarksTree(node).map(serializeNode(true));

const asComponentProps = (
  node: TypedObject,
  index: number,
  isInline: boolean
): ComponentProps => ({
  node,
  index,
  isInline,
  class: astroClass,
});

const provideComponent = (nodeType: keyof typeof components, type: string) => {
  const component = components[nodeType];

  return isComponent(component)
    ? component
    : components[nodeType][type as keyof typeof component];
};

const use = <T, R>(it: T, fn: (it: T) => R) => fn(it);

const prepareForRender = (props: ComponentProps) => {
  const { node } = props;

  const $: (
    nodeSpec: { nodeType: string; type: string | null },
    component: Component | string,
    children?: ComponentProps[]
  ) => [typeof component, ComponentProps[]] = (
    nodeSpec,
    component,
    children
  ) => {
    Object.defineProperty(props.node, nodeTypeRef, {
      value: nodeSpec,
    });

    return [component, children ?? []];
  };

  return isPortableTextToolkitList(node)
    ? use(
        { nodeType: "list" as keyof typeof components, type: node.listItem },
        (spec) => {
          return $(
            spec,
            provideComponent(spec.nodeType, spec.type) ??
              components.unknownList,
            serializeChildren(node, false)
          );
        }
      )
    : isPortableTextListItemBlock(node)
    ? use(
        {
          nodeType: "listItem" as keyof typeof components,
          type: node.listItem,
        },
        (spec) => {
          return $(
            spec,
            provideComponent(spec.nodeType, spec.type) ??
              components.unknownListItem,
            serializeMarksTree(node).map((children) => {
              if (node.style !== "normal") {
                const { listItem, ...blockNode } = node;
                children = serializeNode(false)(blockNode, 0);
              }
              return children;
            })
          );
        }
      )
    : isPortableTextToolkitSpan(node)
    ? use(
        { nodeType: "mark" as keyof typeof components, type: node.markType },
        (spec) => {
          return $(
            spec,
            provideComponent(spec.nodeType, spec.type) ??
              components.unknownMark,
            serializeChildren(node, true)
          );
        }
      )
    : isPortableTextBlock(node)
    ? use(
        {
          nodeType: "block" as keyof typeof components,
          type: node.style ?? "normal",
        },
        (spec) => {
          props.node = { style: spec.type, ...node };

          return $(
            spec,
            provideComponent(spec.nodeType, spec.type) ??
              components.unknownBlock,
            serializeMarksTree(node)
          );
        }
      )
    : isPortableTextToolkitTextNode(node)
    ? $(
        { nodeType: "text", type: null },
        "\n" === node.text && isComponent(components.hardBreak)
          ? components.hardBreak
          : node.text
      )
    : use(
        { nodeType: "type" as keyof typeof components, type: node._type },
        (spec) => {
          return $(
            spec,
            provideComponent(spec.nodeType, spec.type) ?? components.unknownType
          );
        }
      );
};

// Set `provideDefaultComponent` on context
context.provideDefaultComponent = (node: TypedObject): any => {
  const { nodeType } = (node as any)[nodeTypeRef];

  return nodeType === "list" || isPortableTextToolkitList(node)
    ? List
    : nodeType === "listItem" || isPortableTextListItemBlock(node)
    ? ListItem
    : nodeType === "mark" || isPortableTextToolkitSpan(node)
    ? Mark
    : nodeType === "block" || isPortableTextBlock(node)
    ? Block
    : // Should we try for `type`?
      (() => {
        throw new Error(
          `[PortableText provideComponent()] Unable to provide component with node type ${node._type}`
        );
      })();
};

// Set `provideUnknownComponent` on context
context.provideUnknownComponent = (node: TypedObject) => {
  const { nodeType } = (node as any)[nodeTypeRef];

  return (
    nodeType === "list" || isPortableTextToolkitList(node)
      ? components.unknownList
      : nodeType === "listItem" || isPortableTextListItemBlock(node)
      ? components.unknownListItem
      : nodeType === "mark" || isPortableTextToolkitSpan(node)
      ? components.unknownMark
      : nodeType === "block" || isPortableTextBlock(node)
      ? components.unknownBlock
      : nodeType === "type" || !isPortableTextToolkitTextNode(node)
      ? components.unknownType
      : (() => {
          throw new Error(
            `[PortableText provideUnknownComponent()] Unable to provide component with node type ${node._type}`
          );
        })()
  ) as Component;
};

// Set `provideWarningMessage` on context
context.provideWarningMessage = (node: TypedObject) => {
  const { nodeType, type } = (node as any)[nodeTypeRef];

  return getWarningMessage(nodeType, type);
};

// Set `missingComponentHandler` on context
context.provideMissingComponentHandler = missingComponentHandler;

// Using a generator to avoid creating a new array
function* renderBlocks() {
  for (const it of nestLists(blocks, listNestingMode)) {
    yield asComponentProps(it, 0, false);
  }
}
---

{
  [...renderBlocks()].map(function render(props) {
    const [Cmp, children] = prepareForRender(props);

    return !isComponent(Cmp) ? (
      <Fragment set:text={Cmp} />
    ) : (
      <Cmp {...props}>{children.map(render)}</Cmp>
    );
  })
}
