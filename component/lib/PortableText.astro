---
import {
  isPortableTextBlock,
  isPortableTextListItemBlock,
  isPortableTextToolkitList,
  isPortableTextToolkitSpan,
  isPortableTextToolkitTextNode,
  nestLists,
  buildMarksTree,
  LIST_NEST_MODE_HTML,
} from "@portabletext/toolkit";

import mitt from "mitt";

import {
  ComponentOrRecord,
  PortableTextComponents,
  Component,
  Props,
  PortableTextProps,
  TypedObject,
  NodeType,
} from "./types";

import { isComponent, mergeComponents } from "./internal";

import {
  printWarning,
  unknownTypeWarning,
  unknownMarkWarning,
  unknownBlockStyleWarning,
  unknownListStyleWarning,
  unknownListItemStyleWarning,
} from "./warnings";

import NodeRenderer from "./NodeRenderer.astro";

import Block from "./components/Block.astro";
import HardBreak from "./components/HardBreak.astro";
import List from "./components/List.astro";
import ListItem from "./components/ListItem.astro";
import Raw from "./components/Raw.astro";
import Mark from "./components/Mark.astro";
import UnknownBlockStyle from "./components/UnknownBlockStyle.astro";
import UnknownList from "./components/UnknownList.astro";
import UnknownListItem from "./components/UnknownListItem.astro";
import UnknownMark from "./components/UnknownMark.astro";
import UnknownType from "./components/UnknownType.astro";

const {
  value,
  components: componentOverrides = {},
  listNestingMode = LIST_NEST_MODE_HTML,
  onMissingComponent = printWarning,
  class: astroClass,
} = Astro.props as PortableTextProps & { class?: string };

const components = mergeComponents(
  {
    type: {},
    unknownType: UnknownType,
    block: {
      h1: Block,
      h2: Block,
      h3: Block,
      h4: Block,
      h5: Block,
      h6: Block,
      blockquote: Block,
      normal: Block,
    },
    unknownBlockStyle: UnknownBlockStyle,
    list: {
      bullet: List,
      number: List,
    },
    unknownList: UnknownList,
    listItem: {
      bullet: ListItem,
      number: ListItem,
    },
    unknownListItem: UnknownListItem,
    mark: {
      code: Mark,
      em: Mark,
      link: Mark,
      "strike-through": Mark,
      strong: Mark,
      underline: Mark,
    },
    unknownMark: UnknownMark,
    hardBreak: HardBreak,
  },
  componentOverrides
) as PortableTextComponents;

const noop = () => {};
const missingComponentHandler = onMissingComponent || noop;

const emitter = mitt<{
  unknownType: string;
  unknownBlockStyle: string;
  unknownList: string;
  unknownListItem: string;
  unknownMark: string;
}>();

emitter.on("unknownType", (type: string) => {
  missingComponentHandler(unknownTypeWarning(type), {
    nodeType: NodeType.BLOCK,
    type: type,
  });
});

emitter.on("unknownBlockStyle", (style: string) => {
  missingComponentHandler(unknownBlockStyleWarning(style), {
    nodeType: NodeType.BLOCK_STYLE,
    type: style,
  });
});

emitter.on("unknownList", (listItem: string) => {
  missingComponentHandler(unknownListStyleWarning(listItem), {
    nodeType: NodeType.LIST_STYLE,
    type: listItem,
  });
});

emitter.on("unknownListItem", (listItem: string) => {
  missingComponentHandler(unknownListItemStyleWarning(listItem), {
    nodeType: NodeType.LIST_ITEM_STYLE,
    type: listItem,
  });
});

emitter.on("unknownMark", (markType: string) => {
  missingComponentHandler(unknownMarkWarning(markType), {
    nodeType: NodeType.MARK,
    type: markType,
  });
});

const provideComponent = (
  type: "type" | "block" | "list" | "listItem" | "mark",
  fallback:
    | "unknownType"
    | "unknownBlockStyle"
    | "unknownList"
    | "unknownListItem"
    | "unknownMark",
  key: string
): Component => {
  const componentOrRecord = components[type] as ComponentOrRecord;

  if (isComponent(componentOrRecord)) {
    return componentOrRecord;
  }

  if (key in componentOrRecord) {
    return componentOrRecord[key];
  }

  emitter.emit(fallback, key);

  return components[fallback] as Component;
};

const blocks = Array.isArray(value) ? value : [value];
const nested = nestLists(blocks, listNestingMode);

const serializeNode =
  (isInline?: boolean) =>
  (node: TypedObject, index: number): Props =>
    asComponentProps(node, index, isInline);

const asComponentProps = (
  node: any,
  index: number = 0,
  isInline: boolean = false
): Props => ({
  node,
  index,
  isInline,
  astroClass: astroClass,
});
---

{nested
  .map((node) => asComponentProps(node))
  .map(function renderNode(it): any {
    const { node, ...props } = it

    return isPortableTextToolkitList(node) ? (
      <NodeRenderer
        component={provideComponent("list", "unknownList", node.listItem)}
        node={node}
        {...props}
      >
        <Raw value={node.children.map(serializeNode(false)).map(renderNode)} />
      </NodeRenderer>
    ) : isPortableTextListItemBlock(node) ? (
      <NodeRenderer
        component={provideComponent(
          "listItem",
          "unknownListItem",
          node.listItem
        )}
        node={node}
        {...props}
      >
        <Raw
          value={((children) => {
            if (node.style && node.style !== "normal") {
              const { listItem, ...blockNode } = node
              children = renderNode(serializeNode(false)(blockNode, 0))
            }
            return children
          })(buildMarksTree(node).map(serializeNode(true)).map(renderNode))}
        />
      </NodeRenderer>
    ) : isPortableTextToolkitSpan(node) ? (
      <NodeRenderer
        component={provideComponent("mark", "unknownMark", node.markType)}
        node={node}
        {...props}
      >
        <Raw value={node.children.map(serializeNode(true)).map(renderNode)} />
      </NodeRenderer>
    ) : isPortableTextBlock(node) ? (
      <NodeRenderer
        component={provideComponent(
          "block",
          "unknownBlockStyle",
          node.style ?? "normal"
        )}
        node={{ style: "normal", ...node }}
        {...props}
      >
        <Raw
          value={buildMarksTree(node).map(serializeNode(true)).map(renderNode)}
        />
      </NodeRenderer>
    ) : isPortableTextToolkitTextNode(node) ? (
      "\n" === node.text && components["hardBreak"] ? (
        <NodeRenderer component={components["hardBreak"]} node={node} />
      ) : (
        <Fragment set:text={node.text} />
      )
    ) : (
      <NodeRenderer
        component={provideComponent("type", "unknownType", node._type)}
        node={node}
        {...props}
      />
    )
  })}
